CCS PCM C Compiler, Version 5.048, 25478               29-10-15 17:58

               Filename:   C:\Users\denshi\Documents\2015_Tracer_Program\3071_ktanaka\source.lst

               ROM used:   175 words (17%)
                           Largest free fragment is 849
               RAM used:   26 (38%) at main() level
                           26 (38%) worst case
               Stack used: 1 locations
               Stack size: 8

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   024
0003:  NOP
.................... #include <16f84a.h> 
.................... //////////// Standard Header file for the PIC16F84A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F84A 
....................  
.................... #list 
....................  
.................... #fuses HS,PUT,NOWDT,NOPROTECT 
.................... #use delay(clock=20000000) 
*
0011:  MOVLW  24
0012:  MOVWF  04
0013:  MOVF   00,W
0014:  BTFSC  03.2
0015:  GOTO   023
0016:  MOVLW  06
0017:  MOVWF  0D
0018:  CLRF   0C
0019:  DECFSZ 0C,F
001A:  GOTO   019
001B:  DECFSZ 0D,F
001C:  GOTO   018
001D:  MOVLW  7B
001E:  MOVWF  0C
001F:  DECFSZ 0C,F
0020:  GOTO   01F
0021:  DECFSZ 00,F
0022:  GOTO   016
0023:  RETURN
.................... #use fast_io(a) 
.................... #use fast_io(b) 
....................  
.................... //#define backmode 
....................  
.................... #define U3IN1 0 
.................... #define U3IN2 1 
.................... #define U2IN2 2 
.................... #define U2IN1 3 
....................  
.................... //PA感覚で何を書けばいいか書くとよいでしょう。 
.................... #define LS_Right 0 
.................... #define LS_Center 1 
.................... #define LS_Left 2 
....................  
.................... //PBに代入する値です。Vとついてるのはその場回転。 
.................... #ifndef backmode 
.................... #define FORWARD 0b0110	 
.................... #define BACK	0b1001 
.................... #define R_TURN  0b0010 
.................... #define R_TURNV 0b1010 
.................... #define L_TURN  0b0100 
.................... #define L_TURNV 0b0101 
.................... #define STOP 	0b0000 
.................... #define BRAKE	0b1111 
.................... #endif 
....................  
.................... #define PWM_MAX 254 
.................... #define ever (;;) 
....................  
.................... //宣言集 
.................... int SWPwm[4]={0,0,0,0};		//unused 
*
0029:  CLRF   10
002A:  CLRF   11
002B:  CLRF   12
002C:  CLRF   13
....................  
.................... void setup(); 
.................... void TmWait();				//カウンタがフルになるまで待つ 
.................... void mode_judge();			//割り込みモード判定 
.................... void teiki(); 
.................... unsigned int PWM_COUNT=PWM_MAX; 
.................... unsigned int state[3],old_state[3];	//stateはメイン状態/その時間/その他の状態 
.................... int pin[3],old_pin[3];		// 
.................... int i,j,k;					//counterを回す用 
....................  
.................... /* 
.................... interrupt warikomi(){ 
.................... 	if(T0IF){ 
.................... 		PWM_COUNT--; 
.................... 	} 
.................... 	if(RBIF){ 
.................... 		mode_judge(); 
.................... 		RBIF=0; 
.................... 	} 
.................... 	//if while mode judging ,T0 if full. 
.................... 	T0IF = 0; 
.................... } 
....................   */ 
....................  
....................  
.................... void main(){ 
*
0024:  MOVF   03,W
0025:  ANDLW  1F
0026:  MOVWF  03
0027:  MOVLW  FE
0028:  MOVWF  14
.................... 	setup(); 
*
002D:  GOTO   004
.................... 	while(1){ 
.................... 		for(i=0;i<3;i++){ 
002E:  CLRF   21
002F:  MOVF   21,W
0030:  SUBLW  02
0031:  BTFSS  03.0
0032:  GOTO   055
.................... 			old_pin[i]=pin[i]; 
0033:  MOVLW  1E
0034:  ADDWF  21,W
0035:  MOVWF  24
0036:  MOVLW  1B
0037:  ADDWF  21,W
0038:  MOVWF  04
0039:  MOVF   00,W
003A:  MOVWF  25
003B:  MOVF   24,W
003C:  MOVWF  04
003D:  MOVF   25,W
003E:  MOVWF  00
.................... 			pin[i]=input_b() & (1<<(7-i)); 
003F:  MOVLW  1B
0040:  ADDWF  21,W
0041:  MOVWF  04
0042:  MOVF   06,W
0043:  MOVWF  25
0044:  MOVF   21,W
0045:  SUBLW  07
0046:  MOVWF  0D
0047:  MOVLW  01
0048:  MOVWF  0C
0049:  MOVF   0D,F
004A:  BTFSC  03.2
004B:  GOTO   050
004C:  BCF    03.0
004D:  RLF    0C,F
004E:  DECFSZ 0D,F
004F:  GOTO   04C
0050:  MOVF   0C,W
0051:  ANDWF  25,W
0052:  MOVWF  00
0053:  INCF   21,F
0054:  GOTO   02F
.................... 			} 
....................  
.................... 		if(pin[1]==0){output_a(FORWARD);delay_ms(4);j=0;} 
0055:  MOVF   1C,F
0056:  BTFSS  03.2
0057:  GOTO   05F
0058:  MOVLW  06
0059:  MOVWF  05
005A:  MOVLW  04
005B:  MOVWF  24
005C:  CALL   011
005D:  CLRF   22
005E:  GOTO   0A3
.................... 		else if((pin[0]==1)&&(pin[2]==0)){output_a(R_TURNV);delay_ms(4);j=1;} 
005F:  DECFSZ 1B,W
0060:  GOTO   06C
0061:  MOVF   1D,F
0062:  BTFSS  03.2
0063:  GOTO   06C
0064:  MOVLW  0A
0065:  MOVWF  05
0066:  MOVLW  04
0067:  MOVWF  24
0068:  CALL   011
0069:  MOVLW  01
006A:  MOVWF  22
006B:  GOTO   0A3
.................... 		else if((pin[0]==0)&&(pin[2]==1)){output_a(L_TURNV);delay_ms(4);j=1;} 
006C:  MOVF   1B,F
006D:  BTFSS  03.2
006E:  GOTO   079
006F:  DECFSZ 1D,W
0070:  GOTO   079
0071:  MOVLW  05
0072:  MOVWF  05
0073:  MOVLW  04
0074:  MOVWF  24
0075:  CALL   011
0076:  MOVLW  01
0077:  MOVWF  22
0078:  GOTO   0A3
.................... 		else if((pin[0]==0)&&(pin[2]==0)){output_a(BACK);delay_ms(4);} 
0079:  MOVF   1B,F
007A:  BTFSS  03.2
007B:  GOTO   085
007C:  MOVF   1D,F
007D:  BTFSS  03.2
007E:  GOTO   085
007F:  MOVLW  09
0080:  MOVWF  05
0081:  MOVLW  04
0082:  MOVWF  24
0083:  CALL   011
0084:  GOTO   0A3
.................... 		else { 
.................... 				if(j==0) {output_a(FORWARD);} 
0085:  MOVF   22,F
0086:  BTFSS  03.2
0087:  GOTO   08B
0088:  MOVLW  06
0089:  MOVWF  05
008A:  GOTO   0A3
.................... 				else if(j==1){ 
008B:  DECFSZ 22,W
008C:  GOTO   0A3
.................... 				output_a(BACK); 
008D:  MOVLW  09
008E:  MOVWF  05
.................... 				delay_ms(6); 
008F:  MOVLW  06
0090:  MOVWF  24
0091:  CALL   011
.................... 				output_a(L_TURNV); 
0092:  MOVLW  05
0093:  MOVWF  05
.................... 				delay_ms(5); 
0094:  MOVWF  24
0095:  CALL   011
.................... 				if((old_pin[0]||old_pin[2])){ 
0096:  MOVF   1E,F
0097:  BTFSS  03.2
0098:  GOTO   09C
0099:  MOVF   20,F
009A:  BTFSC  03.2
009B:  GOTO   09C
.................... 					//delay_ms(150); 
.................... 				} 
.................... 				output_a(BRAKE); 
009C:  MOVLW  0F
009D:  MOVWF  05
.................... 				delay_us(100); 
009E:  MOVLW  A6
009F:  MOVWF  0C
00A0:  DECFSZ 0C,F
00A1:  GOTO   0A0
00A2:  NOP
.................... 				} 
.................... 		} 
.................... 		//if(j==20){output_a(BACK);delay_ms(50);j=1;} 
.................... 		delay_ms(4); 
00A3:  MOVLW  04
00A4:  MOVWF  24
00A5:  CALL   011
.................... 		output_a(BRAKE); 
00A6:  MOVLW  0F
00A7:  MOVWF  05
.................... 		delay_us(100); 
00A8:  MOVLW  A6
00A9:  MOVWF  0C
00AA:  DECFSZ 0C,F
00AB:  GOTO   0AA
00AC:  NOP
00AD:  GOTO   02E
.................... 	} 
.................... 	} 
....................  
00AE:  SLEEP
....................  
....................  
.................... void setup(){ 
.................... 	//OPTION=0b00000010; 
.................... 	/* 0 PBPU プルアップを使用する。 
.................... 	 * 0 INTEDG 立下りエッジを検出し割り込む 
.................... 	 * 0 TMR0clocksource 内部クロック 
.................... 	 * 0 TMR0のインクリメントタイミング 
.................... 	 * 0 ぷりすけーらーをTMR0に使う。 
.................... 	 * 010 0.8192ms 1/8 
.................... 	   001 0.4096ms 1/16 
.................... 	 */ 
.................... 	 	 
.................... 	 //INTCON=0b10101000; 
.................... 	/* 1 GIE 
.................... 	 * 0 EE  INT EN 
.................... 	 * 1 TM0 INT EN 
.................... 	 * 0 INT INT EN 
.................... 	 * 1 RB  INT EN 
.................... 	 * 0 TM0 INT FLAG 
.................... 	 * 0 INT INT FLAG 
.................... 	 * 0 RB  INT FLAG 
.................... 	 */ 
.................... 	 	 
.................... 	 set_tris_A(0b00010000); 
*
0004:  MOVLW  10
0005:  BSF    03.5
0006:  MOVWF  05
.................... 	 //TRISA=0b00010000; 
.................... 	/* 0 予約 
.................... 	 * 0 予約 
.................... 	 * 0 予約 
.................... 	 * 1  
.................... 	 * 0 17 U3 IN1 
.................... 	 * 0 18 U3 IN2 
.................... 	 * 0 02 U2 IN2 
.................... 	 * 0 01 U2 IN1 
.................... 	 */ 
.................... 	 //PORTA=0; 
.................... 	 output_a(0); 
0007:  BCF    03.5
0008:  CLRF   05
....................  
.................... 	 set_tris_B(0b11111111); 
0009:  MOVLW  FF
000A:  BSF    03.5
000B:  MOVWF  06
.................... 	 //TRISB=0b11111111; 
.................... 	/* 1 13 ラインセンサ 
.................... 	 * 1 12 ラインセンサ 
.................... 	 * 1 11 ラインセンサ 
.................... 	 * 1  
.................... 	 * 1  
.................... 	 * 1  
.................... 	 * 1  
.................... 	 * 1  
.................... 	 */ 
.................... 	 //PORTB=0; 
.................... 	 output_b(0); 
000C:  BCF    03.5
000D:  CLRF   06
.................... 	j=2; 
000E:  MOVLW  02
000F:  MOVWF  22
0010:  GOTO   02E (RETURN)
.................... } 
.................... /*	 
.................... void TmWait(void){ 
.................... 	while(!T0IF); 
.................... 	T0IF = 0; 
.................... } 
.................... */ 
....................  
.................... void mode_judge(void){ 
.................... 	//escape and reading 
.................... 	for(i=0;i<3;i++){ 
.................... 		old_pin[i]=pin[i]; 
.................... 		pin[i]=input_b() & (1<<i); 
.................... 		//pin[i]=PORTB & (1<<i); 
.................... 		old_state[i]=state[i]; 
.................... 	} 
.................... 	 
.................... 	//mode judge 
.................... 	if(!pin[LS_Center]){ 
.................... 		state[0] = FORWARD; 
.................... 		state[2] = STOP; 
.................... 		if(pin[LS_Left]==pin[LS_Right]){ 
.................... 			// b b b or w b w 
.................... 			state[1]=PWM_MAX+1; 
.................... 		} 
.................... 		else{ 
.................... 			if(!pin[LS_Left]){ 
.................... 				//b b w 
.................... 				state[0]=L_TURN; 
.................... 			} 
.................... 			else{ 
.................... 				//w b b 
.................... 				state[0]=R_TURN; 
.................... 			} 
.................... 			state[1]=PWM_MAX/2; 
.................... 			state[2]=FORWARD; 
.................... 		} 
.................... 	} 
.................... 	else if(!pin[LS_Left]){ 
.................... 		if(old_state[0]==L_TURN){ 
.................... 			state[0]=L_TURNV; 
.................... 		} 
.................... 		else{ 
.................... 			state[0]=L_TURN; 
.................... 		} 
.................... 		state[1]=PWM_MAX/2; 
.................... 		state[2]=STOP; 
.................... 	} 
.................... 	else if(!pin[LS_Right]){ 
.................... 		if(old_state[0]==R_TURN){ 
.................... 			state[0]=R_TURNV; 
.................... 		} 
.................... 		else{ 
.................... 			state[0]=R_TURN; 
.................... 		} 
.................... 		state[1]=PWM_MAX/2; 
.................... 		state[2]=STOP; 
.................... 	} 
.................... 	else{ 
.................... 		state[0]=FORWARD; 
.................... 		state[1]=PWM_MAX-1; 
.................... 		state[2]=STOP; 
.................... 	} 
.................... } 
....................  
.................... void teiki(void){ 
.................... 	//escape and reading 
.................... 	for(i=0;i<3;i++){ 
.................... 		old_pin[i]=pin[i]; 
.................... 		pin[i]=input_b() & (1<<i); 
.................... 		//pin[i]=PORTB() & (1<<i); 
.................... 		old_state[i]=state[i]; 
.................... 	} 
.................... 	 
.................... 	//mode judge 
.................... 	if(!pin[LS_Center]){ 
.................... 		state[0] = FORWARD; 
.................... 		state[2] = STOP; 
.................... 		if(pin[LS_Left]==pin[LS_Right]){ 
.................... 			// b b b or w b w 
.................... 			state[1]=PWM_MAX+1; 
.................... 		} 
.................... 		else{ 
.................... 			if(!pin[LS_Left]){ 
.................... 				//b b w 
.................... 				state[0]=L_TURN; 
.................... 			} 
.................... 			else{ 
.................... 				//w b b 
.................... 				state[0]=R_TURN; 
.................... 			} 
.................... 			state[1]=PWM_MAX/2; 
.................... 			state[2]=FORWARD; 
.................... 		} 
.................... 	} 
.................... 	else if(!pin[LS_Left]){ 
.................... 		if(old_state[0]==L_TURN){ 
.................... 			state[0]=L_TURNV; 
.................... 		} 
.................... 		else{ 
.................... 			state[0]=L_TURN; 
.................... 		} 
.................... 		state[1]=PWM_MAX/2; 
.................... 		state[2]=STOP; 
.................... 	} 
.................... 	else if(!pin[LS_Right]){ 
.................... 		if(old_state[0]==R_TURN){ 
.................... 			state[0]=R_TURNV; 
.................... 		} 
.................... 		else{ 
.................... 			state[0]=R_TURN; 
.................... 		} 
.................... 		state[1]=PWM_MAX/2; 
.................... 		state[2]=STOP; 
.................... 	} 
.................... 	else{ 
.................... 		state[0]=FORWARD; 
.................... 		state[1]=PWM_MAX-1; 
.................... 		state[2]=STOP; 
.................... 	} 
.................... } 

Configuration Fuses:
   Word  1: 3FF2   HS NOWDT PUT NOPROTECT
