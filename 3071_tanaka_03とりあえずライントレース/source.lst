CCS PCM C Compiler, Version 5.048, 25478               22-10-15 18:02

               Filename:   C:\Users\denshi\Documents\2015_Tracer_Program\3071_tanaka\source.lst

               ROM used:   165 words (16%)
                           Largest free fragment is 859
               RAM used:   26 (38%) at main() level
                           26 (38%) worst case
               Stack used: 1 locations
               Stack size: 8

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   022
0003:  NOP
.................... #include <16f84a.h> 
.................... //////////// Standard Header file for the PIC16F84A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F84A 
....................  
.................... #list 
....................  
.................... #fuses HS,PUT,NOWDT,NOPROTECT 
.................... #use delay(clock=20000000) 
*
000F:  MOVLW  24
0010:  MOVWF  04
0011:  MOVF   00,W
0012:  BTFSC  03.2
0013:  GOTO   021
0014:  MOVLW  06
0015:  MOVWF  0D
0016:  CLRF   0C
0017:  DECFSZ 0C,F
0018:  GOTO   017
0019:  DECFSZ 0D,F
001A:  GOTO   016
001B:  MOVLW  7B
001C:  MOVWF  0C
001D:  DECFSZ 0C,F
001E:  GOTO   01D
001F:  DECFSZ 00,F
0020:  GOTO   014
0021:  RETURN
.................... #use fast_io(a) 
.................... #use fast_io(b) 
....................  
.................... //#define backmode 
....................  
.................... #define U3IN1 0 
.................... #define U3IN2 1 
.................... #define U2IN2 2 
.................... #define U2IN1 3 
....................  
.................... //PA感覚で何を書けばいいか書くとよいでしょう。 
.................... #define LS_Right 0 
.................... #define LS_Center 1 
.................... #define LS_Left 2 
....................  
.................... //PBに代入する値です。Vとついてるのはその場回転。 
.................... #ifndef backmode 
.................... #define FORWARD 0b0110	 
.................... #define BACK	0b1001 
.................... #define R_TURN  0b0010 
.................... #define R_TURNV 0b1010 
.................... #define L_TURN  0b0100 
.................... #define L_TURNV 0b0101 
.................... #define STOP 	0b0000 
.................... #define BRAKE	0b1111 
.................... #endif 
....................  
.................... #define PWM_MAX 254 
.................... #define ever (;;) 
....................  
.................... //宣言集 
.................... int SWPwm[4]={0,0,0,0};		//unused 
*
0027:  CLRF   10
0028:  CLRF   11
0029:  CLRF   12
002A:  CLRF   13
....................  
.................... void setup(); 
.................... void TmWait();				//カウンタがフルになるまで待つ 
.................... void mode_judge();			//割り込みようモード判定 
.................... void teiki(); 
.................... unsigned int PWM_COUNT=PWM_MAX; 
.................... unsigned int state[3],old_state[3];	//stateはメイン状態/その時間/その他の状態 
.................... int pin[3],old_pin[3];		// 
.................... int i,j,k;					//counterを回す用 
....................  
.................... /* 
.................... interrupt warikomi(){ 
.................... 	if(T0IF){ 
.................... 		PWM_COUNT--; 
.................... 	} 
.................... 	if(RBIF){ 
.................... 		mode_judge(); 
.................... 		RBIF=0; 
.................... 	} 
.................... 	//if while mode judging ,T0 if full. 
.................... 	T0IF = 0; 
.................... } 
....................   */ 
....................  
....................  
.................... void main(){ 
*
0022:  MOVF   03,W
0023:  ANDLW  1F
0024:  MOVWF  03
0025:  MOVLW  FE
0026:  MOVWF  14
.................... 	setup(); 
*
002B:  GOTO   004
.................... 	while(1){ 
.................... 		for(i=0;i<3;i++){ 
002C:  CLRF   21
002D:  MOVF   21,W
002E:  SUBLW  02
002F:  BTFSS  03.0
0030:  GOTO   053
.................... 			old_pin[i]=pin[i]; 
0031:  MOVLW  1E
0032:  ADDWF  21,W
0033:  MOVWF  24
0034:  MOVLW  1B
0035:  ADDWF  21,W
0036:  MOVWF  04
0037:  MOVF   00,W
0038:  MOVWF  25
0039:  MOVF   24,W
003A:  MOVWF  04
003B:  MOVF   25,W
003C:  MOVWF  00
.................... 			pin[i]=input_b() & (1<<(7-i)); 
003D:  MOVLW  1B
003E:  ADDWF  21,W
003F:  MOVWF  04
0040:  MOVF   06,W
0041:  MOVWF  25
0042:  MOVF   21,W
0043:  SUBLW  07
0044:  MOVWF  0D
0045:  MOVLW  01
0046:  MOVWF  0C
0047:  MOVF   0D,F
0048:  BTFSC  03.2
0049:  GOTO   04E
004A:  BCF    03.0
004B:  RLF    0C,F
004C:  DECFSZ 0D,F
004D:  GOTO   04A
004E:  MOVF   0C,W
004F:  ANDWF  25,W
0050:  MOVWF  00
0051:  INCF   21,F
0052:  GOTO   02D
.................... 			} 
....................  
.................... 		if(pin[1]==0){output_a(FORWARD);} 
0053:  MOVF   1C,F
0054:  BTFSS  03.2
0055:  GOTO   059
0056:  MOVLW  06
0057:  MOVWF  05
0058:  GOTO   080
.................... 		else if(pin[0]==0){output_a(R_TURNV);delay_ms(8);j=1;} 
0059:  MOVF   1B,F
005A:  BTFSS  03.2
005B:  GOTO   064
005C:  MOVLW  0A
005D:  MOVWF  05
005E:  MOVLW  08
005F:  MOVWF  24
0060:  CALL   00F
0061:  MOVLW  01
0062:  MOVWF  22
0063:  GOTO   080
.................... 		else if(pin[2]==0){output_a(L_TURNV);delay_ms(8);j=1;} 
0064:  MOVF   1D,F
0065:  BTFSS  03.2
0066:  GOTO   06F
0067:  MOVLW  05
0068:  MOVWF  05
0069:  MOVLW  08
006A:  MOVWF  24
006B:  CALL   00F
006C:  MOVLW  01
006D:  MOVWF  22
006E:  GOTO   080
.................... 		else {	j++; 
006F:  INCF   22,F
.................... 				output_a(BACK); 
0070:  MOVLW  09
0071:  MOVWF  05
.................... 				delay_ms(3); 
0072:  MOVLW  03
0073:  MOVWF  24
0074:  CALL   00F
.................... 				output_a(STOP); 
0075:  CLRF   05
.................... 				delay_us(100); 
0076:  MOVLW  A6
0077:  MOVWF  0C
0078:  DECFSZ 0C,F
0079:  GOTO   078
007A:  NOP
.................... 				output_a(R_TURN); 
007B:  MOVLW  02
007C:  MOVWF  05
.................... 				delay_ms(1);} 
007D:  MOVLW  01
007E:  MOVWF  24
007F:  CALL   00F
.................... 		//if(j==20){output_a(BACK);delay_ms(50);j=1;} 
.................... 		delay_ms(1); 
0080:  MOVLW  01
0081:  MOVWF  24
0082:  CALL   00F
.................... 		output_a(STOP); 
0083:  CLRF   05
.................... 		delay_us(100); 
0084:  MOVLW  A6
0085:  MOVWF  0C
0086:  DECFSZ 0C,F
0087:  GOTO   086
0088:  NOP
0089:  GOTO   02C
.................... 	} 
.................... 	state[0]=FORWARD; 
008A:  MOVLW  06
008B:  MOVWF  15
.................... 	state[1]=200; 
008C:  MOVLW  C8
008D:  MOVWF  16
.................... 	state[2]=L_TURN; 
008E:  MOVLW  04
008F:  MOVWF  17
.................... 	for (;;) { 
.................... 		for (PWM_COUNT=PWM_MAX;PWM_COUNT<1;PWM_COUNT--){ 
0090:  MOVLW  FE
0091:  MOVWF  14
0092:  MOVF   14,F
0093:  BTFSS  03.2
0094:  GOTO   0A3
.................... 			if(state[1]>PWM_COUNT) 	output_a(state[0]); 
0095:  MOVF   16,W
0096:  SUBWF  14,W
0097:  BTFSC  03.0
0098:  GOTO   09C
0099:  MOVF   15,W
009A:  MOVWF  05
009B:  GOTO   09E
.................... 			else 					output_a(state[2]); 
009C:  MOVF   17,W
009D:  MOVWF  05
.................... 			delay_ms(100); 
009E:  MOVLW  64
009F:  MOVWF  24
00A0:  CALL   00F
00A1:  DECF   14,F
00A2:  GOTO   092
.................... 		} 
00A3:  GOTO   090
.................... 	} 
.................... } 
....................  
00A4:  SLEEP
....................  
.................... void setup(){ 
.................... 	//OPTION=0b00000010; 
.................... 	/* 0 PBPU プルアップを使用する。 
.................... 	 * 0 INTEDG 立下りエッジを検出し割り込む 
.................... 	 * 0 TMR0clocksource 内部クロック 
.................... 	 * 0 TMR0のインクリメントタイミング 
.................... 	 * 0 ぷりすけーらーをTMR0に使う。 
.................... 	 * 010 0.8192ms 1/8 
.................... 	   001 0.4096ms 1/16 
.................... 	 */ 
.................... 	 	 
.................... 	 //INTCON=0b10101000; 
.................... 	/* 1 GIE 
.................... 	 * 0 EE  INT EN 
.................... 	 * 1 TM0 INT EN 
.................... 	 * 0 INT INT EN 
.................... 	 * 1 RB  INT EN 
.................... 	 * 0 TM0 INT FLAG 
.................... 	 * 0 INT INT FLAG 
.................... 	 * 0 RB  INT FLAG 
.................... 	 */ 
.................... 	 	 
.................... 	 set_tris_A(0b00010000); 
*
0004:  MOVLW  10
0005:  BSF    03.5
0006:  MOVWF  05
.................... 	 //TRISA=0b00010000; 
.................... 	/* 0 予約 
.................... 	 * 0 予約 
.................... 	 * 0 予約 
.................... 	 * 1  
.................... 	 * 0 17 U3 IN1 
.................... 	 * 0 18 U3 IN2 
.................... 	 * 0 02 U2 IN2 
.................... 	 * 0 01 U2 IN1 
.................... 	 */ 
.................... 	 //PORTA=0; 
.................... 	 output_a(0); 
0007:  BCF    03.5
0008:  CLRF   05
....................  
.................... 	 set_tris_B(0b11111111); 
0009:  MOVLW  FF
000A:  BSF    03.5
000B:  MOVWF  06
.................... 	 //TRISB=0b11111111; 
.................... 	/* 1 13 ラインセンサ 
.................... 	 * 1 12 ラインセンサ 
.................... 	 * 1 11 ラインセンサ 
.................... 	 * 1  
.................... 	 * 1  
.................... 	 * 1  
.................... 	 * 1  
.................... 	 * 1  
.................... 	 */ 
.................... 	 //PORTB=0; 
.................... 	 output_b(0); 
000C:  BCF    03.5
000D:  CLRF   06
000E:  GOTO   02C (RETURN)
....................  
.................... 	  
.................... 	  
.................... 	 //TIMER 
.................... /*temp aaa 
.................... 	 CLRWDT(); 
.................... 	 TMR0=0; 
.................... 	 T0IE=0; 
.................... 	 T0IF=0; 
....................  
.................... } 
.................... 	 
.................... void TmWait(void){ 
.................... 	while(!T0IF); 
.................... 	T0IF = 0; 
.................... } 
.................... aaa temp*/ 
.................... } 
....................  
.................... void mode_judge(void){ 
.................... 	//escape and reading 
.................... 	for(i=0;i<3;i++){ 
.................... 		old_pin[i]=pin[i]; 
.................... 		pin[i]=input_b() & (1<<i); 
.................... 		//pin[i]=PORTB & (1<<i); 
.................... 		old_state[i]=state[i]; 
.................... 	} 
.................... 	 
.................... 	//mode judge 
.................... 	if(!pin[LS_Center]){ 
.................... 		state[0] = FORWARD; 
.................... 		state[2] = STOP; 
.................... 		if(pin[LS_Left]==pin[LS_Right]){ 
.................... 			// b b b or w b w 
.................... 			state[1]=PWM_MAX+1; 
.................... 		} 
.................... 		else{ 
.................... 			if(!pin[LS_Left]){ 
.................... 				//b b w 
.................... 				state[0]=L_TURN; 
.................... 			} 
.................... 			else{ 
.................... 				//w b b 
.................... 				state[0]=R_TURN; 
.................... 			} 
.................... 			state[1]=PWM_MAX/2; 
.................... 			state[2]=FORWARD; 
.................... 		} 
.................... 	} 
.................... 	else if(!pin[LS_Left]){ 
.................... 		if(old_state[0]==L_TURN){ 
.................... 			state[0]=L_TURNV; 
.................... 		} 
.................... 		else{ 
.................... 			state[0]=L_TURN; 
.................... 		} 
.................... 		state[1]=PWM_MAX/2; 
.................... 		state[2]=STOP; 
.................... 	} 
.................... 	else if(!pin[LS_Right]){ 
.................... 		if(old_state[0]==R_TURN){ 
.................... 			state[0]=R_TURNV; 
.................... 		} 
.................... 		else{ 
.................... 			state[0]=R_TURN; 
.................... 		} 
.................... 		state[1]=PWM_MAX/2; 
.................... 		state[2]=STOP; 
.................... 	} 
.................... 	else{ 
.................... 		state[0]=FORWARD; 
.................... 		state[1]=PWM_MAX-1; 
.................... 		state[2]=STOP; 
.................... 	} 
.................... } 
....................  
.................... void teiki(void){ 
.................... 	//escape and reading 
.................... 	for(i=0;i<3;i++){ 
.................... 		old_pin[i]=pin[i]; 
.................... 		pin[i]=input_b() & (1<<i); 
.................... 		//pin[i]=PORTB() & (1<<i); 
.................... 		old_state[i]=state[i]; 
.................... 	} 
.................... 	 
.................... 	//mode judge 
.................... 	if(!pin[LS_Center]){ 
.................... 		state[0] = FORWARD; 
.................... 		state[2] = STOP; 
.................... 		if(pin[LS_Left]==pin[LS_Right]){ 
.................... 			// b b b or w b w 
.................... 			state[1]=PWM_MAX+1; 
.................... 		} 
.................... 		else{ 
.................... 			if(!pin[LS_Left]){ 
.................... 				//b b w 
.................... 				state[0]=L_TURN; 
.................... 			} 
.................... 			else{ 
.................... 				//w b b 
.................... 				state[0]=R_TURN; 
.................... 			} 
.................... 			state[1]=PWM_MAX/2; 
.................... 			state[2]=FORWARD; 
.................... 		} 
.................... 	} 
.................... 	else if(!pin[LS_Left]){ 
.................... 		if(old_state[0]==L_TURN){ 
.................... 			state[0]=L_TURNV; 
.................... 		} 
.................... 		else{ 
.................... 			state[0]=L_TURN; 
.................... 		} 
.................... 		state[1]=PWM_MAX/2; 
.................... 		state[2]=STOP; 
.................... 	} 
.................... 	else if(!pin[LS_Right]){ 
.................... 		if(old_state[0]==R_TURN){ 
.................... 			state[0]=R_TURNV; 
.................... 		} 
.................... 		else{ 
.................... 			state[0]=R_TURN; 
.................... 		} 
.................... 		state[1]=PWM_MAX/2; 
.................... 		state[2]=STOP; 
.................... 	} 
.................... 	else{ 
.................... 		state[0]=FORWARD; 
.................... 		state[1]=PWM_MAX-1; 
.................... 		state[2]=STOP; 
.................... 	} 
.................... } 

Configuration Fuses:
   Word  1: 3FF2   HS NOWDT PUT NOPROTECT
